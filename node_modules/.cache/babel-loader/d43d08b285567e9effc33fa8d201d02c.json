{"ast":null,"code":"/* eslint-disable max-len */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { updateItem, resolveItemsIds } from './utils/itemUtils';\nimport { EXPAND_FIELD, SELECT_FIELD, CHECK_FIELD, CHECK_INDETERMINATE_FIELD, CHILDREN_FIELD } from './utils/consts';\nimport { getNestedValue, isArray } from './utils/misc';\n/**\n * A helper function which applies the specified operation descriptors to the data.\n * * [Expanding and collapsing items]({% slug expansion_ways_treeview %}#toc-using-a-helper-function)\n * * [Selecting and deselecting items]({% slug selection_ways_treeview %}#toc-using-a-helper-function)\n * * [Checking and unchecking items]({% slug check_helper_funcs_treeview %})\n *\n * @param data - The data that will be processed.\n * @param operations - The operation descriptors that will be applied to the data.\n * @returns - The processed copy of the input data.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     state = { items: tree, expand: [], select: [], check: [] };\n *     render() {\n *         const { expand, select, check } = this.state;\n *         return (\n *             <TreeView\n *                 data={processTreeViewItems(this.state.items, { expand, select, check })}\n *                 expandIcons={true} onExpandChange={this.onExpandChange} checkboxes={true}\n *                 onCheckChange={event => this.setState({ check: [ event.itemHierarchicalIndex ] })}\n *                 onItemClick={event => this.setState({ select: [ event.itemHierarchicalIndex ] })}\n *             />\n *         );\n *     }\n *     onExpandChange = (event) => {\n *         let expand = this.state.expand.slice();\n *         const index = expand.indexOf(event.itemHierarchicalIndex);\n *         index === -1 ? expand.push(event.itemHierarchicalIndex) : expand.splice(index, 1);\n *         this.setState({ expand });\n *     }\n * }\n *\n * const tree = [{\n *     text: 'Item1',\n *     items: [\n *         { text: 'Item1.1' },\n *         { text: 'Item1.2' },\n *         { text: 'Item1.3', items: [{ text: 'Item1.3.1' }] }]\n * }, {\n *     text: 'Item2', disabled: true,\n *     items: [{ text: 'Item2.1' }, { text: 'Item2.2' }, { text: 'Item2.3' }]\n * }, {\n *     text: 'Item3'\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nexport default function processTreeViewItems(data, operations) {\n  if (!data || !data.length) {\n    return [];\n  }\n\n  var result = data;\n  var cloneField = operations.cloneField || 'cloned';\n  var expandField = operations.expandField || EXPAND_FIELD;\n  var selectField = operations.selectField || SELECT_FIELD;\n  var checkField = operations.checkField || CHECK_FIELD;\n  var childrenField = operations.childrenField || CHILDREN_FIELD;\n  result = handleOperation(result, expandField, operations.expand, cloneField, childrenField);\n  result = handleOperation(result, selectField, operations.select, cloneField, childrenField);\n  result = handleOperation(result, checkField, operations.check, cloneField, childrenField);\n  applyCheckIndeterminate(result, childrenField, operations.check);\n  return result;\n}\n\nfunction handleOperation(items, defaultField, operation, cloneField, childrenField) {\n  if (operation) {\n    var _a = parseOperation(operation, defaultField),\n        ids = _a.ids,\n        field = _a.field;\n\n    var indices = !isArray(operation) && operation.idField ? resolveItemsIds(ids, operation.idField, items, childrenField) : ids;\n    return raiseFlags(items, indices, field, cloneField, childrenField);\n  } else {\n    return items;\n  }\n}\n\nfunction parseOperation(operation, defaultField) {\n  var ids;\n  var field;\n\n  if (isArray(operation)) {\n    ids = operation;\n    field = defaultField;\n  } else {\n    ids = operation.ids || [];\n    field = operation.operationField || defaultField;\n  }\n\n  return {\n    ids: ids,\n    field: field\n  };\n}\n\nfunction raiseFlags(items, indices, field, cloneField, childrenField) {\n  var result = items;\n  indices.forEach(function (itemIndex) {\n    result = updateItem(result, itemIndex, function (item) {\n      return raiseNestedFlag(field, item);\n    }, cloneField, childrenField);\n  });\n  return result;\n}\n\nfunction raiseNestedFlag(fieldName, dataItem) {\n  var fields = (fieldName || '').split('.');\n  var item = dataItem;\n\n  for (var index = 0; index < fields.length; index++) {\n    var field = fields[index];\n\n    if (index === fields.length - 1) {\n      item[field] = true;\n    } else if (item[field] !== undefined) {\n      item[field] = __assign({}, item[field]);\n      item = item[field];\n    } else {\n      return;\n    }\n  }\n}\n\nfunction applyCheckIndeterminate(items, childrenField, check) {\n  if (check && !isArray(check) && check.applyCheckIndeterminate) {\n    var checkField = parseOperation(check, CHECK_FIELD).field;\n    var checkIndeterminateField = check.checkIndeterminateField || CHECK_INDETERMINATE_FIELD;\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      var subItems = item[childrenField];\n\n      if (subItems) {\n        applyCheckIndeterminateHelper(subItems, getNestedValue(checkField, item) ? [] : [item], childrenField, checkField, checkIndeterminateField);\n      }\n    }\n  }\n}\n\nfunction applyCheckIndeterminateHelper(data, parents, childrenField, checkField, checkIndeterminateField) {\n  // The updates will be direct because the corresponding items\n  // are already cloned because of their checked children.\n  var parentsAlreadyUpdated = false;\n\n  for (var i = 0; i < data.length; i++) {\n    var item = data[i];\n\n    if (getNestedValue(checkField, item)) {\n      if (!parentsAlreadyUpdated) {\n        for (var j = 0; j < parents.length; j++) {\n          raiseNestedFlag(checkIndeterminateField, parents[j]);\n        }\n      }\n\n      parentsAlreadyUpdated = true;\n\n      if (item[childrenField]) {\n        applyCheckIndeterminateHelper(item[childrenField], [], childrenField, checkField, checkIndeterminateField);\n      }\n    } else {\n      if (item[childrenField]) {\n        applyCheckIndeterminateHelper(item[childrenField], parentsAlreadyUpdated ? [item] : parents.concat([item]), childrenField, checkField, checkIndeterminateField);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../src/processTreeViewItems.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable max-len */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { updateItem, resolveItemsIds } from './utils/itemUtils';\nimport { EXPAND_FIELD, SELECT_FIELD, CHECK_FIELD, CHECK_INDETERMINATE_FIELD, CHILDREN_FIELD } from './utils/consts';\nimport { getNestedValue, isArray } from './utils/misc';\n/**\n * A helper function which applies the specified operation descriptors to the data.\n * * [Expanding and collapsing items]({% slug expansion_ways_treeview %}#toc-using-a-helper-function)\n * * [Selecting and deselecting items]({% slug selection_ways_treeview %}#toc-using-a-helper-function)\n * * [Checking and unchecking items]({% slug check_helper_funcs_treeview %})\n *\n * @param data - The data that will be processed.\n * @param operations - The operation descriptors that will be applied to the data.\n * @returns - The processed copy of the input data.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     state = { items: tree, expand: [], select: [], check: [] };\n *     render() {\n *         const { expand, select, check } = this.state;\n *         return (\n *             <TreeView\n *                 data={processTreeViewItems(this.state.items, { expand, select, check })}\n *                 expandIcons={true} onExpandChange={this.onExpandChange} checkboxes={true}\n *                 onCheckChange={event => this.setState({ check: [ event.itemHierarchicalIndex ] })}\n *                 onItemClick={event => this.setState({ select: [ event.itemHierarchicalIndex ] })}\n *             />\n *         );\n *     }\n *     onExpandChange = (event) => {\n *         let expand = this.state.expand.slice();\n *         const index = expand.indexOf(event.itemHierarchicalIndex);\n *         index === -1 ? expand.push(event.itemHierarchicalIndex) : expand.splice(index, 1);\n *         this.setState({ expand });\n *     }\n * }\n *\n * const tree = [{\n *     text: 'Item1',\n *     items: [\n *         { text: 'Item1.1' },\n *         { text: 'Item1.2' },\n *         { text: 'Item1.3', items: [{ text: 'Item1.3.1' }] }]\n * }, {\n *     text: 'Item2', disabled: true,\n *     items: [{ text: 'Item2.1' }, { text: 'Item2.2' }, { text: 'Item2.3' }]\n * }, {\n *     text: 'Item3'\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport default function processTreeViewItems(data, operations) {\n    if (!data || !data.length) {\n        return [];\n    }\n    var result = data;\n    var cloneField = operations.cloneField || 'cloned';\n    var expandField = operations.expandField || EXPAND_FIELD;\n    var selectField = operations.selectField || SELECT_FIELD;\n    var checkField = operations.checkField || CHECK_FIELD;\n    var childrenField = operations.childrenField || CHILDREN_FIELD;\n    result = handleOperation(result, expandField, operations.expand, cloneField, childrenField);\n    result = handleOperation(result, selectField, operations.select, cloneField, childrenField);\n    result = handleOperation(result, checkField, operations.check, cloneField, childrenField);\n    applyCheckIndeterminate(result, childrenField, operations.check);\n    return result;\n}\nfunction handleOperation(items, defaultField, operation, cloneField, childrenField) {\n    if (operation) {\n        var _a = parseOperation(operation, defaultField), ids = _a.ids, field = _a.field;\n        var indices = !isArray(operation) && operation.idField ? resolveItemsIds(ids, operation.idField, items, childrenField) : ids;\n        return raiseFlags(items, indices, field, cloneField, childrenField);\n    }\n    else {\n        return items;\n    }\n}\nfunction parseOperation(operation, defaultField) {\n    var ids;\n    var field;\n    if (isArray(operation)) {\n        ids = operation;\n        field = defaultField;\n    }\n    else {\n        ids = operation.ids || [];\n        field = operation.operationField || defaultField;\n    }\n    return { ids: ids, field: field };\n}\nfunction raiseFlags(items, indices, field, cloneField, childrenField) {\n    var result = items;\n    indices.forEach(function (itemIndex) {\n        result = updateItem(result, itemIndex, function (item) { return raiseNestedFlag(field, item); }, cloneField, childrenField);\n    });\n    return result;\n}\nfunction raiseNestedFlag(fieldName, dataItem) {\n    var fields = (fieldName || '').split('.');\n    var item = dataItem;\n    for (var index = 0; index < fields.length; index++) {\n        var field = fields[index];\n        if (index === fields.length - 1) {\n            item[field] = true;\n        }\n        else if (item[field] !== undefined) {\n            item[field] = __assign({}, item[field]);\n            item = item[field];\n        }\n        else {\n            return;\n        }\n    }\n}\nfunction applyCheckIndeterminate(items, childrenField, check) {\n    if (check && !isArray(check) && check.applyCheckIndeterminate) {\n        var checkField = parseOperation(check, CHECK_FIELD).field;\n        var checkIndeterminateField = check.checkIndeterminateField || CHECK_INDETERMINATE_FIELD;\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            var subItems = item[childrenField];\n            if (subItems) {\n                applyCheckIndeterminateHelper(subItems, getNestedValue(checkField, item) ? [] : [item], childrenField, checkField, checkIndeterminateField);\n            }\n        }\n    }\n}\nfunction applyCheckIndeterminateHelper(data, parents, childrenField, checkField, checkIndeterminateField) {\n    // The updates will be direct because the corresponding items\n    // are already cloned because of their checked children.\n    var parentsAlreadyUpdated = false;\n    for (var i = 0; i < data.length; i++) {\n        var item = data[i];\n        if (getNestedValue(checkField, item)) {\n            if (!parentsAlreadyUpdated) {\n                for (var j = 0; j < parents.length; j++) {\n                    raiseNestedFlag(checkIndeterminateField, parents[j]);\n                }\n            }\n            parentsAlreadyUpdated = true;\n            if (item[childrenField]) {\n                applyCheckIndeterminateHelper(item[childrenField], [], childrenField, checkField, checkIndeterminateField);\n            }\n        }\n        else {\n            if (item[childrenField]) {\n                applyCheckIndeterminateHelper(item[childrenField], parentsAlreadyUpdated ? [item] : parents.concat([item]), childrenField, checkField, checkIndeterminateField);\n            }\n        }\n    }\n}\n//# sourceMappingURL=processTreeViewItems.js.map"]},"metadata":{},"sourceType":"module"}