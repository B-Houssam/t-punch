{"ast":null,"code":"import { addItem, removeItem } from './utils/itemUtils';\nimport { getDecrementedItemIdAfterRemoval, getItemById } from './utils/itemIdUtils';\nimport { CHILDREN_FIELD } from './utils/consts';\n/**\n *  A helper function which moves a TreeView item in an immutable way.\n *\n * @param sourceItemHierarchicalIndex - The hierarchical index of the item that will be moved.\n * @param sourceData - The tree which contains the item that will be moved.\n * @param operation - The specific move operation.\n *\n * The available options are:\n *  * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.\n *  * `after`&mdash;Indicates that the source item will become the next sibling of the target item.\n *  * `child`&mdash;Indicates that the source item will become a child of the target item.\n * @param targetItemHierarchicalIndex - The hierarchical index of the item next to which the source item will be moved.\n * @param targetData - The tree which contains the target item.\n * If the argument is skipped, then the move operation will be executed within the same tree.\n * Setting the `sourceData` and `targetData` arguments to the same tree is also supported.\n * @param childrenField - The field that points to the dataItem sub items. Defaults to `items`.\n * @returns - The updated copies of the `sourceData` and `targetData` input arguments.\n * If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nexport default function moveTreeViewItem(sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData, childrenField) {\n  var subItemsField = childrenField || CHILDREN_FIELD;\n\n  if (!validateInput()) {\n    return prepareInputDataForReturn();\n  }\n\n  var sourceItem = getItemById(sourceItemHierarchicalIndex, sourceData, subItemsField);\n\n  if (!sourceItem) {\n    return prepareInputDataForReturn();\n  } // The source and the target tree are the same.\n\n\n  if (!targetData || targetData === sourceData) {\n    if (!validateNoCircularReference()) {\n      return prepareInputDataForReturn();\n    }\n\n    var updatedSourceData = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n    var resultData = addItem(sourceItem, operation, subItemsField, getDecrementedItemIdAfterRemoval(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData); // A simpler output is explicitly returned when the source and the target tree are\n    // the same, that is, the targetData argument is skipped.\n\n    return targetData ? {\n      sourceData: resultData,\n      targetData: resultData\n    } : resultData;\n  } else {\n    var updatedSource = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n    var updatedTarget = addItem(sourceItem, operation, subItemsField, targetItemHierarchicalIndex, targetData);\n    return {\n      sourceData: updatedSource,\n      targetData: updatedTarget\n    };\n  }\n\n  function prepareInputDataForReturn() {\n    return targetData ? {\n      sourceData: sourceData,\n      targetData: targetData\n    } : sourceData;\n  }\n\n  function validateNoCircularReference() {\n    return !(targetItemHierarchicalIndex + \"_\").startsWith(sourceItemHierarchicalIndex + \"_\");\n  }\n\n  function validateInput() {\n    if (!sourceData || !sourceData.length || !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {\n      return false;\n    }\n\n    if (targetData && !targetData.length) {\n      // Dropping over an empty tree is not supported.\n      return false;\n    } // Validate that the target item exists.\n\n\n    var data = !targetData || targetData === sourceData ? sourceData : targetData;\n\n    if (!getItemById(targetItemHierarchicalIndex, data, subItemsField)) {\n      return false;\n    }\n\n    return true;\n  }\n}","map":{"version":3,"sources":["../../src/moveTreeViewItem.ts"],"names":[],"mappings":"AAAA,SAAS,OAAT,EAAkB,UAAlB,QAAoC,mBAApC;AACA,SAAS,gCAAT,EAA2C,WAA3C,QAA8D,qBAA9D;AACA,SAAS,cAAT,QAA+B,gBAA/B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwGG;;AACH,eAAc,SAAU,gBAAV,CACV,2BADU,EAEV,UAFU,EAGV,SAHU,EAIV,2BAJU,EAKV,UALU,EAMV,aANU,EAMY;AAEtB,MAAM,aAAa,GAAG,aAAa,IAAI,cAAvC;;AAEA,MAAI,CAAC,aAAa,EAAlB,EAAsB;AAClB,WAAO,yBAAyB,EAAhC;AACH;;AAED,MAAM,UAAU,GAAG,WAAW,CAAC,2BAAD,EAA8B,UAA9B,EAA0C,aAA1C,CAA9B;;AACA,MAAI,CAAC,UAAL,EAAiB;AACb,WAAO,yBAAyB,EAAhC;AACH,GAXqB,CAatB;;;AACA,MAAI,CAAC,UAAD,IAAe,UAAU,KAAK,UAAlC,EAA8C;AAC1C,QAAI,CAAC,2BAA2B,EAAhC,EAAoC;AAChC,aAAO,yBAAyB,EAAhC;AACH;;AAED,QAAM,iBAAiB,GAAG,UAAU,CAAC,2BAAD,EAA8B,aAA9B,EAA6C,UAA7C,CAApC;AACA,QAAM,UAAU,GAAG,OAAO,CACtB,UADsB,EAEtB,SAFsB,EAGtB,aAHsB,EAItB,gCAAgC,CAAC,2BAAD,EAA8B,2BAA9B,CAJV,EAKtB,iBALsB,CAA1B,CAN0C,CAc1C;AACA;;AACA,WAAO,UAAU,GAAG;AAAE,MAAA,UAAU,EAAE,UAAd;AAA0B,MAAA,UAAU,EAAE;AAAtC,KAAH,GAAwD,UAAzE;AACH,GAjBD,MAiBO;AACH,QAAM,aAAa,GAAG,UAAU,CAAC,2BAAD,EAA8B,aAA9B,EAA6C,UAA7C,CAAhC;AACA,QAAM,aAAa,GAAG,OAAO,CAAC,UAAD,EAAa,SAAb,EAAwB,aAAxB,EAAuC,2BAAvC,EAAoE,UAApE,CAA7B;AAEA,WAAO;AAAE,MAAA,UAAU,EAAE,aAAd;AAA6B,MAAA,UAAU,EAAE;AAAzC,KAAP;AACH;;AAED,WAAS,yBAAT,GAAkC;AAC9B,WAAO,UAAU,GAAG;AAAE,MAAA,UAAU,EAAA,UAAZ;AAAc,MAAA,UAAU,EAAA;AAAxB,KAAH,GAAgC,UAAjD;AACH;;AAED,WAAS,2BAAT,GAAoC;AAChC,WAAO,CAAC,CAAG,2BAA2B,GAAA,GAA9B,EAAkC,UAAlC,CAAgD,2BAA2B,GAAA,GAA3E,CAAR;AACH;;AAED,WAAS,aAAT,GAAsB;AAClB,QAAI,CAAC,UAAD,IAAe,CAAC,UAAU,CAAC,MAA3B,IACA,CAAC,2BADD,IACgC,CAAC,2BADrC,EACkE;AAC9D,aAAO,KAAP;AACH;;AACD,QAAI,UAAU,IAAI,CAAC,UAAU,CAAC,MAA9B,EAAsC;AAClC;AACA,aAAO,KAAP;AACH,KARiB,CAUlB;;;AACA,QAAM,IAAI,GAAG,CAAC,UAAD,IAAe,UAAU,KAAK,UAA9B,GAA2C,UAA3C,GAAwD,UAArE;;AACA,QAAI,CAAC,WAAW,CAAC,2BAAD,EAA8B,IAA9B,EAAoC,aAApC,CAAhB,EAAoE;AAChE,aAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACH;AACJ","sourceRoot":"","sourcesContent":["import { addItem, removeItem } from './utils/itemUtils';\nimport { getDecrementedItemIdAfterRemoval, getItemById } from './utils/itemIdUtils';\nimport { CHILDREN_FIELD } from './utils/consts';\n/**\n *  A helper function which moves a TreeView item in an immutable way.\n *\n * @param sourceItemHierarchicalIndex - The hierarchical index of the item that will be moved.\n * @param sourceData - The tree which contains the item that will be moved.\n * @param operation - The specific move operation.\n *\n * The available options are:\n *  * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.\n *  * `after`&mdash;Indicates that the source item will become the next sibling of the target item.\n *  * `child`&mdash;Indicates that the source item will become a child of the target item.\n * @param targetItemHierarchicalIndex - The hierarchical index of the item next to which the source item will be moved.\n * @param targetData - The tree which contains the target item.\n * If the argument is skipped, then the move operation will be executed within the same tree.\n * Setting the `sourceData` and `targetData` arguments to the same tree is also supported.\n * @param childrenField - The field that points to the dataItem sub items. Defaults to `items`.\n * @returns - The updated copies of the `sourceData` and `targetData` input arguments.\n * If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport default function moveTreeViewItem(sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData, childrenField) {\n    var subItemsField = childrenField || CHILDREN_FIELD;\n    if (!validateInput()) {\n        return prepareInputDataForReturn();\n    }\n    var sourceItem = getItemById(sourceItemHierarchicalIndex, sourceData, subItemsField);\n    if (!sourceItem) {\n        return prepareInputDataForReturn();\n    }\n    // The source and the target tree are the same.\n    if (!targetData || targetData === sourceData) {\n        if (!validateNoCircularReference()) {\n            return prepareInputDataForReturn();\n        }\n        var updatedSourceData = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n        var resultData = addItem(sourceItem, operation, subItemsField, getDecrementedItemIdAfterRemoval(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData);\n        // A simpler output is explicitly returned when the source and the target tree are\n        // the same, that is, the targetData argument is skipped.\n        return targetData ? { sourceData: resultData, targetData: resultData } : resultData;\n    }\n    else {\n        var updatedSource = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n        var updatedTarget = addItem(sourceItem, operation, subItemsField, targetItemHierarchicalIndex, targetData);\n        return { sourceData: updatedSource, targetData: updatedTarget };\n    }\n    function prepareInputDataForReturn() {\n        return targetData ? { sourceData: sourceData, targetData: targetData } : sourceData;\n    }\n    function validateNoCircularReference() {\n        return !(targetItemHierarchicalIndex + \"_\").startsWith(sourceItemHierarchicalIndex + \"_\");\n    }\n    function validateInput() {\n        if (!sourceData || !sourceData.length ||\n            !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {\n            return false;\n        }\n        if (targetData && !targetData.length) {\n            // Dropping over an empty tree is not supported.\n            return false;\n        }\n        // Validate that the target item exists.\n        var data = !targetData || targetData === sourceData ? sourceData : targetData;\n        if (!getItemById(targetItemHierarchicalIndex, data, subItemsField)) {\n            return false;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=moveTreeViewItem.js.map"]},"metadata":{},"sourceType":"module"}